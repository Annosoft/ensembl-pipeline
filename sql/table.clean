CREATE TABLE job (
  job_id            int(10) unsigned DEFAULT '0' NOT NULL auto_increment,
  input_id          varchar(40) DEFAULT '' NOT NULL,
  class             enum("clone", "contig", "vc", "gene") not null,
  analysis_id       smallint(5) unsigned DEFAULT '0' NOT NULL,
  lsf_id            mediumint(10) unsigned DEFAULT '0',
  stdout_file       varchar(100) DEFAULT '' NOT NULL,
  stderr_file       varchar(100) DEFAULT '' NOT NULL,
  object_file       varchar(100) DEFAULT '' NOT NULL,
  retry_count       tinyint(2) unsigned default 0,

  PRIMARY KEY (job_id),
  KEY (input_id),
  KEY (analysis_id)
);

# job_id      - job internal ID
# input_id    - name (e.g. accession/Ensembl ID) of input
# class       - distinguish different input types
# analysis_id - internal ID of analysis (analysis table)
# lsf_id      - ID of job in LSF
# *_file      - files created to contain job output/error
# retry_count - number of times job restarted

# ?? what is job.objectfile - do we need/use it?




CREATE TABLE job_status (
  job_id            int(10) unsigned DEFAULT '0' NOT NULL,
  status            varchar(40) DEFAULT 'CREATED' NOT NULL,
  time              datetime DEFAULT NOT NULL,
  is_current        enum('y', 'n') DEFAULT 'n'

  KEY (job_id),
  KEY (status),
  KEY (is_current)
);

# job 'history' table - tracks each state of a job in its 'life'
# one line per job/status
#
# job_id     - job internal ID
# status     - text string (e.g. 'CREATED' , 'RUNNING')
# is_current - whether this status is the current status



# rule tables: rule_goal and rule_conditions
#
# an analysis A depends on a number of rules R1 .. RN. it can
# be run when all rules with rule_goal.analysis = A are satisfied.
# in order to satisfy a rule R, at least one of the conditions
# rule_conditions.condition must have been met for that rule.
#
# rule_goal.analysis and rule_conditions.contitions relate to
# entries in table 'analysis'
# currently, rule_goal.analysis is an analysis internal ID,
# rule_conditions.condition is an analysis logic_name

CREATE TABLE rule_goal (
  rule_id           smallint(5) unsigned default '0' not null auto_increment,
  analysis_id       smallint(5) unsigned,
 
  PRIMARY KEY (rule_id)
);

CREATE TABLE rule_conditions (
  rule_id           smallint(10) unsigned not null,
  condition         varchar(40)
);

# rule_id     - rule internal ID
# analysis_id - internal ID of analysis
# condition   - a literal, such as analysis.logic_name

# ?? rule_goal.analysis_id - could this be a string
# (logic_name) instead of an internal_id?
# need also to include rules like 'run job X on all contigs'



CREATE TABLE input_id_analysis (
  input_id          varchar(40) not null,
  class             enum("clone" ,"contig", "vc", "gene") not null,
  analysis_id       smallint(10) unsigned DEFAULT '0' NOT NULL,
  created           datetime NOT NULL,

  PRIMARY KEY (analysis_id, input_id, class),
  KEY input_created (input_id, created),
  KEY input_class (input_id, class)
);

# pipeline 'history' table - records each job performed in the
# pipeline with the time it was completed
#
# input_id/class/analysis_id - see table 'job'
# timestamp                  - when this job was completed

# ?? need an extra column to hold exit status
# e.g. for repeat masked seq need to know if seq is all repeat
# (prevent e.g. blast running) - and store failures here that
# are understood (e.g. genscan producing garbage)
# and if, say, no genscan predictions, don't bother BlastGenscanXXX

