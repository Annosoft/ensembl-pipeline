#!/usr/local/bin/perl -w

BEGIN {
  # oooh this is not nice
  my $script_dir = $0;
  $script_dir =~ s/(\S+\/)\S+/$1/;
  unshift (@INC, $script_dir);
}

=head1 NAME

  pmatch_proteome

=head1 SYNOPSIS
 
  pmatch_proteome

=head1 DESCRIPTION

=head1 OPTIONS
  
  Options are to be set in GeneBuild config files
  The important ones for this script are:
     GeneBuild::Scripts::GB_PFASTA      clean file of proteins in fasta format
     GeneBuild::Scripts::GB_PMATCH      location of the pmatch executable
     GeneBuild::Scripts::GB_PM_OUTPUT   directory to write filtered output files
     GeneBuild::Scripts::GB_FPCDIR      top of the hierarchy where the fpcctg fasta files are
     GeneBuild::Scripts::GB_OUTPUT_DIR  scratch area

     GeneBuild::Databases::GB_DBNAME
     GeneBuild::Databases::GB_DBHOST
     GeneBuild::Databases::GB_DBUSER
     GeneBuild::Databases::GB_DBPASS

=cut

use strict;
use pmatch_modules; 
use Bio::Seq;
use File::Find;
use Getopt::Long;
use FileHandle;

use Bio::EnsEMBL::DBSQL::DBAdaptor;

use Bio::EnsEMBL::Pipeline::Config::GeneBuild::Scripts qw (
					                   GB_PFASTA
					                   GB_PMATCH
					                   GB_PM_OUTPUT
					                   GB_OUTPUT_DIR  
                                                          );

use Bio::EnsEMBL::Pipeline::Config::GeneBuild::Databases qw (
                                                             GB_DBHOST
                                                             GB_DBUSER
                                                             GB_DBNAME
                                                             GB_DBPASS
                                                            );
$| = 1;

# global vars
my %plengths; # stores lengths of all proteins in $protfile 

my @hits;     # stores the hits from pmatch runs
my $protfile = $GB_PFASTA;
my $outdir   = $GB_PM_OUTPUT;
my $pmatch   = $GB_PMATCH;
my $tmpdir   = $GB_OUTPUT_DIR;
my $check    = 0;
my $outfile;
my $chrname;
my $chrstart;
my $chrend;
my $run_pmatch = 1; # 1 to run pmatch, 0 if pmatch already run
my $pmatchfile; # can provide a pmatch results file - will be sorted by both protein id and chr_start
                # gets ignored if run_pmatch is set

my $db = new Bio::EnsEMBL::DBSQL::DBAdaptor(-host => $GB_DBHOST,
                                            -user => $GB_DBUSER,
                                            -dbname => $GB_DBNAME,
                                            -pass   => $GB_DBPASS);

#$db->assembly_type($GB_DBPATH);
my $sa = $db->get_SliceAdaptor;

&GetOptions( 
	    'check'         => \$check,
	    'chr:s'         => \$chrname,
	    'chrstart:n'    => \$chrstart,
	    'chrend:n'      => \$chrend,
	    'protfile:s'    => \$protfile,
	    'run_pmatch'    => \$run_pmatch,
	    'pmatchfile:s'  => \$pmatchfile,
	   );

if ($check) {
  exit(0);
}

# final check to make sure all parameters are set before we go ahead
if(!defined($protfile) || !defined($pmatch) || 
   $protfile eq '' || $pmatch eq ''){
  print "You must set GB_PFASTA and GB_PMATCH in the config file, GeneBuild config files: $protfile : $pmatch\n";
  exit (0);
} 

if(!defined($chrname)) {
  print "You must specify a chromosome to be pmatched\n";
  exit (0);
} 

$outfile = "$chrname.$chrstart-$chrend.pm.out";

if (defined ($outdir) && $outdir ne '') {
  $outfile = $outdir . "/" . $outfile;
}

### MAIN

# Generate a fasta file for this piece of chromosome

my $slice  = $sa ->fetch_by_chr_start_end($chrname,$chrstart,$chrend);
my $seq = $slice->seq;
$seq =~ s/(.{72})/$1\n/g;

my $fastafile =  "/tmp/$chrname.$chrstart-$chrend.$$.fa";

open(OUT,">$fastafile") || die "Couldn't open $fastafile";

print OUT ">$chrname.$chrstart-$chrend\n";
print OUT "$seq\n";

close(OUT);

# populate %plengths
&make_protlist;

  print STDERR "processing $fastafile\n";

  if($run_pmatch){
    # generate pmatchfile
    $pmatchfile = "/tmp/$chrname.$chrstart-$chrend.pmatch";
    my $pmatch = $GB_PMATCH;

    # run pmatch -D
    system("$pmatch -D $protfile $fastafile > $pmatchfile");
  }
  elsif(defined $pmatchfile){
    # use a different outfile
    $outfile = $outdir . "/" . $pmatchfile . ".pm.out";
  }
  elsif(!defined $pmatchfile){
    die "you need to either tell me to run_pmatch, or you need to give me a pmatch results file\n";
  }

  &process_pmatches($fastafile);

  # tidy up files we have created
  unlink $pmatchfile unless !$run_pmatch;
  unlink $fastafile;

### END MAIN
### SUBROUTINES

sub process_pmatches{
  my($fastafile) = @_;
  # sort pmatch results file
  system("sort -k6,6 -k3,3n $pmatchfile > $pmatchfile.tmp");
  rename "$pmatchfile.tmp", $pmatchfile;

  open (OUT, ">>$outfile") or die "Can't open $outfile for output: $!\n";
  OUT->autoflush(1);

  open(PMATCHES, "<$pmatchfile") or die "can't open [$pmatchfile]\n";  
  my $prot_id;
  my $current_pmf = new First_PMF(
				  -plengths => \%plengths,
				  -protfile => $protfile,
				  -pmatch   => $pmatch,
				  -tmpdir   => $tmpdir,
				  -fpcfile  => $fastafile,
				  -maxintronlen => 2500000,
				 );
  
 PMATCH:  
  while(<PMATCHES>){
    my @cols = split;
    # dump out line to file just in case this turns into a problem
    
    if(!defined $prot_id || $cols[5] ne $prot_id){
	# process current_pmf
	foreach my $hit($current_pmf->merge_hits) {
	  print  OUT $hit->query  . ":" . 
	         $hit->qstart . "," . 
	         $hit->qend   . ":" . 
	         $hit->target . ":" .
	         $hit->tstart . "," .
	         $hit->tend   . " " .
	         $hit->coverage . "\n";
	}

      # start a new PMF
      $current_pmf = new First_PMF(
				   -plengths => \%plengths,
				   -protfile => $protfile,
				   -pmatch   => $pmatch,
				   -tmpdir   => $tmpdir,
				   -fpcfile  => $fastafile,
				   -maxintronlen => 2500000,
				  );
      $prot_id = $cols[5];
      $current_pmf->make_coord_pair($_);
    }
    else{
      # add this hit into current PMF
      $current_pmf->make_coord_pair($_);
    }
  }

  # make sure we at least try to proces the last one!
  foreach my $hit($current_pmf->merge_hits) {
    print  OUT $hit->query  . ":" . 
               $hit->qstart . "," . 
	       $hit->qend   . ":" . 
	       $hit->target . ":" .
	       $hit->tstart . "," .
	       $hit->tend   . " " .
	       $hit->coverage . "\n";
  }



  close (OUT) or die "Can't close $outfile: $!\n";
  close (PMATCHES) or die "can't close pmatchfile: $!\n";

}



### SUBROUTINES

=head2 make_protlist

 Title   : make_protlist
 Usage   :
 Function: gets lengths for proteins in $protfile & stores them in %plengths. For some 
           reason Bio::SeqIO just returns me the first sequence ...
 Example :
 Returns : 
 Args    :


=cut

sub make_protlist{
  print STDERR "making prot_length list from $protfile\n";
  open (INFILE, "<$protfile") or die "Can't open $protfile\n";
  $/ = '>'; # looks for fields separated by > instead of just "\n"
 SEQFETCH:
  while(<INFILE>) {
    my @lines = split /\n/;
    next SEQFETCH unless scalar(@lines) > 1;
    my $description = shift (@lines);
    $description =~ /(\S+)/; # find the first block of non-whitespace

    next SEQFETCH unless defined $description and $description ne '';
    my $bs = new Bio::Seq;
    $bs->display_id($1);
    
    my $seq;
    foreach my $line(@lines) {
      chomp $line;
      $seq .= $line;
    }
    
    $bs->seq($seq);
    
    $plengths{$bs->display_id} = $bs->length;
  }

  # note double quotes ...    
  $/ = "\n";
  close INFILE;
}

