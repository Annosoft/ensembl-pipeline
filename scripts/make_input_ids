#!/usr/local/bin/perl

=head1 NAME

make_input_ids  - handles insertion, deletion and listing of rules in a database

=head1 SYNOPSIS

make_input_ids -dbhost ecs1a -dbuser ensadmin -dbpass **** -dbname pipeline_db -contig

=head1 DESCRIPTION

this script allows input_ids to be generated and written to the input_id_analysis table for

=head1 OPTIONS

    -dbhost    host name for database (gets put as host= in locator)

    -dbport    For RDBs, what port to connect to (port= in locator)

    -dbname    For RDBs, what name to connect to (dbname= in locator)

    -dbuser    For RDBs, what username to connect as (user= in locator)

    -dbpass    For RDBs, what password to use (pass= in locator)

    -help      Displays script documentation with PERLDOC


    -logic_name the logic_name of the analysis object which needs to be 
                associated with these entries 
    
    -slice     signals to insert slice type input ids using
               the format chrname.start-end

    -coord_system the coordinate system you want slices in
    
    -coord_system_version the version of the coord system you want

    -slice_size the size to make the slice ids

    -slice_overlap the slice overlap (non-overlapping by default)
    
    -file     if the input_ids are to be a list of filenames from a directory
    
    -dir      the directory to read the filenames from
    
    -file_regex a regex to impose on the filenames before using them
    
    -single if you just want a single dummy input_id ie for genome wide analyses
    
    -translation_ids if you want your input ids to be translation ids
    -verbose if you want more information about what the script is doing
    -non_redundant fetch all non redundant pieces

    -input_type if you want to override the standard input_id types

=head1 EXAMPLES

./make_input_ids -dbhost host -dbuser user -dbpass *** -dbport 3306 
  -dbname my_database -contig

this will use all the contig names are input_ids

./make_input_ids -dbhost host -dbuser user -dbpass *** -dbport 3306 
  -dbname my_database -slice -slice_size 1000000

this will make slice names in the format chr_name.start-end all 1M in size

./make_input_ids -dbhost host -dbuser user -dbpass *** -dbport 3306 
  -dbname my_database -file -dir path/to/dir

this will use all the filenames in the dir specified as input_ids

./make_input_ids -dbhost host -dbuser user -dbpass *** -dbport 3306 
  -dbname my_database -file -dir path/to/dir -regex /chunk/

this will use all the filenames in dir which match the specifed regex
as input_ids


./make_input_ids -dbhost host -dbuser user -dbpass *** -dbport 3306 
  -dbname my_database -translation_ids

this will use all the translation ids as input_ids

=cut



use Bio::EnsEMBL::Pipeline::Analysis;
use Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Pipeline::Utils::InputIDFactory;
use Bio::EnsEMBL::Pipeline::DBSQL::StateInfoContainer;
use Bio::EnsEMBL::Utils::Exception qw(throw warning);
use strict;
use Getopt::Long;

my $host;
my $user;
my $pass;
my $port = 3306;
my $dbname;
my $logic_name;
my $slice_size;
my $slice_overlap;
my $type;
my $coord_system;
my $cs_version;
my $slice;
my $input_type;
my $file;
my $dir;
my $regex;
my $single;
my $verbose;
my $help = 0;
my $translation_id;
my $non_redundant;
my $name = 'genome';
&GetOptions(
            'dbhost:s'     => \$host,
            'dbport:n'     => \$port,
            'dbuser:s'     => \$user,
            'dbpass:s'     => \$pass,
            'dbname:s'     => \$dbname,
            'coord_system:s'       => \$coord_system,
            'coord_system_version:s' => \$cs_version,
            'slice'        => \$slice,
            'slice_size:s' => \$slice_size,
            'slice_overlap:s' => \$slice_overlap,
            'logic_name:s' => \$logic_name,
            'input_type:s' => \$input_type,
            'file'         => \$file,
            'dir:s'        => \$dir,
            'file_regex:s' => \$regex,
            'single'       => \$single,
            'single_name:s'=> \$name,
            'verbose'      => \$verbose,
            'translation_id' => \$translation_id,
            'non_redundant' => \$non_redundant,
            'h|help'            => \$help,
           );

if ($help) {
    exec('perldoc', $0);
}

if(!$host || !$user || !$dbname){
  throw("Can't run without -dbhost $host -dbuser $user -dbname $dbname");
  exec('perldoc', $0);
}
my $db = new Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor(-host   => $host,
                                                      -user   => $user,
                                                      -pass   => $pass,
                                                      -port   => $port,
                                                      -dbname => $dbname);


if (!($slice) && !($single) && !($file) && !($translation_id) 
    && !($non_redundant)) {
  throw("Must define input as either contig, slice, file, translation_id ".
  "or single");
  exec('perldoc', $0);
}

if(!$logic_name){
  throw("Can't run with out a logic_name");
  exec('perldoc', $0);
}

my $inputIDFactory = new Bio::EnsEMBL::Pipeline::Utils::InputIDFactory(-db => $db);

my $analysis = $db->get_AnalysisAdaptor->fetch_by_logic_name($logic_name);



if( ($slice + $non_redundant + $single + $file + $translation_id) > 1){
  die "must only define one of these options on the commandline ".
    "-slice $slice -non_redundant $non_redundant -single $single -file $file ".
    " -translation_id $translation_id";
}

$input_type = $analysis->input_id_type unless($input_type);

my @ids;

if ($slice) {
 
  $input_type = "SLICE" unless $input_type;
  die ("Must define a coord system name when fetching slice names") 
    unless($coord_system);

  $cs_version = '' unless($cs_version);
  
  @ids = $inputIDFactory->generate_slice_input_ids($coord_system, $cs_version, $slice_size, $slice_overlap); 
}elsif($single){
  $input_type = 'GENOME' unless $input_type;
  @ids = ($name);
}elsif($file){
  $input_type = 'FILENAME' unless $input_type;
  if(!$dir){
    die "if you want to use filenames as a input ids you must provide".
      " a directory to get them from"; 
  }
  @ids = $inputIDFactory->generate_filename_input_ids($dir, $regex);
}elsif($translation_id){
  @ids = $inputIDFactory->generate_translation_id_input_ids;
}elsif($non_redundant){
  @ids = $inputIDFactory->generate_non_redundant_input_ids;
}else{
    exec('perldoc', $0);
}






if (!($analysis)) {
    $analysis = new Bio::EnsEMBL::Pipeline::Analysis(-logic_name    => $logic_name,
                                                     -input_id_type => $input_type);

    print "storing analysis ".$analysis->logic_name."\n" if($verbose);
 
    $db->get_AnalysisAdaptor->store($analysis);
    if(!$analysis->logic_name){
      die "you  must specify a logic_name for your analysis otherwise".
	" this won't work properly\n";
    }
  }

print STDERR "have analysis ".$analysis->logic_name ." ".$analysis->input_id_type."\n";
$analysis->input_id_type($input_type) if(!$analysis->input_id_type); 

foreach my $id (@ids) {
    eval {
      print STDERR "Storing input id $id - type " . $analysis->input_id_type . "\n" if($verbose);

      $db->get_StateInfoContainer->store_input_id_analysis($id,$analysis, '');  
    
    };
    if ($@) {
      print "Input id $id already present $@";
    }
}
