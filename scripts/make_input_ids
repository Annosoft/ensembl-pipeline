#!/usr/local/bin/perl

use Bio::EnsEMBL::Pipeline::Analysis;
use Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Pipeline::Utils::InputIDFactory;
use Bio::EnsEMBL::Pipeline::DBSQL::StateInfoContainer;

use strict;
use Getopt::Long;

my $host;
my $user = 'ensadmin';
my $pass = 'ensembl';
my $port = 3306;
my $dbname;
my $logic_name;
my $slice_size;
my $type;
my $contig;
my $slice;
my $input_type;
my $file;
my $dir;
my $regex;
my $single;
my $verbose;


&GetOptions(
            'host:s'       => \$host,
            'port:n'       => \$port,
            'user:s'       => \$user,
            'pass:s'       => \$pass,
            'dbname:s'     => \$dbname,
	    'contig'       => \$contig,
	    'slice'        => \$slice,
            'slice_size:s' => \$slice_size,
            'logic_name:s' => \$logic_name,
            'input_type:s' => \$input_type,
	    'file'         => \$file,
	    'dir:s'        => \$dir,
	    'file_regex:s' => \$regex,
	    'single'       => \$single,
            'verbose'      => \$verbose,
           );


my $db = new Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor(-host   => $host,
                                                      -user   => $user,
                                                      -pass   => $pass,
                                                      -port   => $port,
                                                      -dbname => $dbname);
if ($type) {
    $db->assembly_type($type);
} else {
    $type = $db->assembly_type;
}
if (!($type)) {
    die "No assemby type defined";
}

if (!($contig) && !($slice) && !($single) && !($file)) {
  die "Must define input as either contig, slice file or single";
}

my $inputIDFactory = new Bio::EnsEMBL::Pipeline::Utils::InputIDFactory(-db => $db);

my $analysis = $db->get_AnalysisAdaptor->fetch_by_logic_name($logic_name);



if( ($slice + $contig + $single + $file) > 1){
  die "must only define one of these options on the commandline ".
    "-slice $slice -contig $contig -single $single -file $file";
}

my @ids;

if ($slice) {
 
  $input_type = "SLICE" unless $input_type;
  
  @ids = $inputIDFactory->generate_slice_input_ids($slice_size);
  
}elsif($contig) {

  $input_type = "CONTIG" unless $input_type;
  @ids = $inputIDFactory->generate_contig_input_ids;
  
}elsif($single){
  $input_type = 'GENOME' unless $input_type;
  @ids = ('genome');
}elsif($file){
  $input_type = 'FILENAME' unless $input_type;
  if(!$dir){
    die "if you want to use filenames as a input ids you must provide".
      " a directory to get them from"; 
  }
  @ids = $inputIDFactory->generate_filename_input_ids($dir, $regex);
}





if (!($analysis)) {
    $analysis = new Bio::EnsEMBL::Pipeline::Analysis(-logic_name    => $logic_name,
                                                     -input_id_type => $input_type);

    print "storing analysis ".$analysis->logic_name."\n" if($verbose);
 
    $db->get_AnalysisAdaptor->store($analysis);
    if(!$analysis->logic_name){
      die "you  must specify a logic_name for your analysis otherwise".
	" this won't work properly\n";
    }
  }

$analysis->input_id_type($input_type); 

foreach my $id (@ids) {
    eval {
      print STDERR "Storing input id $id - type " . $analysis->input_id_type . "\n" if($verbose);

      $db->get_StateInfoContainer->store_input_id_analysis($id,$analysis);  
    };
    if ($@) {
      print "Input id $id already present $@";
    }
}
