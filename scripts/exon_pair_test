#!/usr/local/bin/perl

BEGIN {
  unshift (@INC,"/nfs/disk89/michele/bioperl-live");
  unshift (@INC,"/nfs/disk89/michele/pogdir/ensembl/modules");
  unshift (@INC,"/nfs/disk89/michele/pogdir/ensembl/ensembl-pipeline/modules");
}

=head1 NAME

retransfer_Features  - transfers features for a list of input clones
=head1 SYNOPSIS
 
  update.pl

=head1 DESCRIPTION

This script transfers all the features attached to a clone to a new
database and deletes any existing features

=head1 OPTIONS

    -host      host name for database (gets put as host= in locator)

    -port      For RDBs, what port to connect to (port= in locator)

    -dbname    For RDBs, what name to connect to (dbname= in locator)

    -dbuser    For RDBs, what username to connect as (dbuser= in locator)

    -dbpass    For RDBs, what password to use (dbpass= in locator)

    -help      Displays script documentation with PERLDOC
    
    -nowrite   Runs entire script without writing in recipient

    -verbose   Gets all the print STDERR for testing purposes

=cut


use strict;
use Getopt::Long;

use Bio::EnsEMBL::Pipeline::Runnable::CloneExonPair;
use Bio::EnsEMBL::Pipeline::SimpleJob;
use Bio::EnsEMBL::Pipeline::DBSQL::Job;
use Bio::EnsEMBL::Pipeline::DBSQL::Clone;
use Bio::EnsEMBL::Pipeline::DBSQL::Contig;
use Bio::EnsEMBL::Pipeline::DBSQL::Obj;

use Bio::EnsEMBL::DBSQL::Obj;
use Bio::EnsEMBL::DBLoader;

use vars qw(@ISA);

@ISA = qw(Bio::Root::Object);

my $fdbtype = 'rdb';
my $fhost   = 'obi-wan';
my $fport   = '410000';
my $fdbname = 'ensembl';
my $fdbuser = 'ensro';
my $fpass   = undef;
my $tdbtype = 'rdb';
my $thost   = 'croc';
my $tport   = '410000';
my $tdbname = 'analysis';
my $tdbuser = 'root';
my $tpass   = undef;

my $fmodule  = "Bio::EnsEMBL::DBSQL::Obj";
my $tmodule  = "Bio::EnsEMBL::Pipeline::DBSQL::Obj";

my $help;
my $usefile;

&GetOptions( 
	     'fdbtype:s'  => \$fdbtype,
	     'fhost:s'    => \$fhost,
	     'fport:n'    => \$fport,
	     'fdbname:s'  => \$fdbname,
	     'fdbuser:s'  => \$fdbuser,
	     'fpass:s'    => \$fpass,
	     'tdbtype:s'  => \$tdbtype,
	     'thost:s'    => \$thost,
	     'tport:n'    => \$tport,
	     'tdbname:s'  => \$tdbname,
	     'tdbuser:s'  => \$tdbuser,
	     'tpass:s'    => \$tpass,
	     'usefile=s'  => \$usefile,
	     'h|help'    => \$help,
	     );


if ($help) {
    exec('perldoc', $0);
}


$| = 1;

my $from_locator     = make_locator_string($fdbtype,$fmodule,$fhost,$fport,$fdbname,$fdbuser,$fpass);
my $to_locator       = make_locator_string($tdbtype,$tmodule,$thost,$tport,$tdbname,$tdbuser,$tpass);

my @cloneids         = read_clones($usefile,@ARGV);

my $tdb              = new Bio::EnsEMBL::DBLoader($to_locator);
my $fdb              = new Bio::EnsEMBL::DBLoader($from_locator);

my $analysis = new Bio::EnsEMBL::Pipeline::Analysis  (-db              => '__NONE__',
						      -db_version      => '__NONE__',
						      -db_file         => '__NONE__',
						      -program         => 'exon_pair_test',
						      -program_version => -1,
						      -program_file    => '__NONE__',
						      -module          => 'Bio::EnsEMBL::Pipeline::Runnable::CloneExonPair.pm',
						      -module_version  => 1,
						      -gff_source      => 'exon_pair',
						      -gff_feature     => 'prediction',
						      -parameters      => "");

$tdb->write_Analysis($analysis);

foreach my $cloneid (@cloneids) {
    eval {

	my $fclone = $fdb   ->get_Clone($cloneid);
	my $tclone = new Bio::EnsEMBL::Pipeline::DBSQL::Clone(-disk_id => "none",
							      -dbobj   => $tdb);
	my @contig;

	foreach my $contig ($fclone->get_all_Contigs) {

	    my @features = $contig->get_all_SeqFeatures;
	    my @genes    = $contig->get_all_Genes;


	    my $tcontig  = new Bio::EnsEMBL::Pipeline::DBSQL::Contig(-id    => $contig->id,
								     -dbobj => $tdb);


	    $tclone->add_Contig($tcontig);

	    foreach my $f (@features) {
		$tcontig->add_SimilarityFeature($f);
	    }

	    foreach my $gene (@genes) {
		
		foreach my $exon ($gene->each_unique_Exon) {
		    $tdb ->write_Exon($exon);
		    $exon->find_supporting_evidence(\@features);
		}

		$tcontig->add_Gene($gene);

	    }

         }
	    my $job      = new Bio::EnsEMBL::Pipeline::DBSQL::Job(-dbobj    => $tdb,
						      -input_id => $fclone->id,
						      -analysis => $analysis,
						      -queue    => 'blast_farm',
						      -create   => 1,
                                                      -file_output => 1,
						      );
            $job->make_files;

	    print(STDERR "Created new job object\n");

	    my $runnable = new Bio::EnsEMBL::Pipeline::Runnable::CloneExonPair(-clone => $tclone);

	    my $simjob  = new Bio::EnsEMBL::Pipeline::SimpleJob(-jobobj   => $job,
								-runnable => $runnable);

	    my $id      = $simjob->id;         

            $simjob->store;
	    $simjob->submit;

	
    };

    if ($@) {
	print("ERROR processing clone $cloneid [$@]\n");
    }
}

	   
sub read_clones {
    my ($file,@clones) = @_;

    my @out;

    if (defined($file)) {
	open(IN,"<$file") || die "Can't open $file";
    }

    while (<IN>) {
	chomp;
	push(@out,$_);
    }

    push(@out,@clones);

    return @out;
}

sub make_locator_string {
    my ($type,$module,$host,$port,$dbname,$dbuser,$dbpass) = @_;

    if ($type eq "rdb") {
	return 	"$module/host=$host;port=$port;dbname=$dbname;user=$dbuser;pass=$dbpass";
    } elsif ($type eq "timdb") {
	return "Bio::EnsEMBL::TimDB::Obj";
    } else {
	die "Database type [$type] not recognised\n";
    }
}



