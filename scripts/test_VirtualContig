#!/usr/local/bin/perl

BEGIN {
  unshift (@INC,"/nfs/disk100/humpub/michele/ensembl/ensembl-pipeline/modules");
  unshift (@INC,"/nfs/disk100/humpub/michele/ensembl/modules");
  unshift (@INC,"/nfs/disk100/humpub/michele/bioperl-06");
}


=head1 NAME

test_RunnableDB

=head1 SYNOPSIS
 
  test_RunnableDB

=head1 DESCRIPTION


=head1 OPTIONS

    -host      host name for database (gets put as host= in locator)

    -port      For RDBs, what port to connect to (port= in locator)

    -dbname    For RDBs, what name to connect to (dbname= in locator)

    -dbuser    For RDBs, what username to connect as (dbuser= in locator)

    -dbpass    For RDBs, what password to use (dbpass= in locator)

    -input_id  The input id for the RunnableDB

    -runnable  The name of the runnable module we want to run

=cut
$| = 1;
use strict;
use Getopt::Long;

use Bio::EnsEMBL::DBSQL::Obj;
use Bio::EnsEMBL::DBLoader;
use Bio::EnsEMBL::DB::VirtualContig;
use Bio::EnsEMBL::DB::WriteableVirtualContig;

use vars qw(@ISA);

@ISA = qw(Bio::Root::Object);

my $dbtype = 'rdb';
my $host   = 'localhost';
my $port   = '410000';
my $dbname = 'ensembl_freeze24';
my $dbuser = 'root';
my $pass   = undef;
my $runnable;
my $input_id;
my $perl   = 1;
my $write  = 0;

&GetOptions( 
	     'host:s'     => \$host,
	     'port:n'     => \$port,
	     'dbname:s'   => \$dbname,
	     'dbuser:s'   => \$dbuser,
	     'pass:s'     => \$pass,
	     'input_id:s' => \$input_id,
	     'runnable:s' => \$runnable,
	     'perl'       => \$perl,
	     'write'      => \$write,
	     );

$| = 1;

my $module  = "Bio::EnsEMBL::Pipeline::DBSQL::Obj";

my $locator = make_locator_string($dbtype,$module,$host,$port,$dbname,$dbuser,$pass,$perl);

my $db      = new Bio::EnsEMBL::DBLoader($locator);

die "No input id entered" unless defined ($input_id);

my $contig  = $db->get_Contig($input_id);
my $focus   = int(($contig->golden_end - $contig->golden_start)/2);
my $ori     = 1;

my $vc      = new Bio::EnsEMBL::DB::VirtualContig(-focuscontig   => $contig,
                                                  -focusposition => $focus,
                                                  -ori           => $ori,
       						  -left          => 1000000000,
						  -right         => 1000000000);
	

$vc->primary_seq;

my @genscan;
my @exons;

foreach my $f ($vc->get_all_SimilarityFeatures) {

  if ($f->source_tag eq "genscan") {
      eval {
      print ("\n Testing genscan " . $f->id . "\t" . $f->seqname . "\n");
      my @tmpexons = test_genscan($f,$vc);

      push(@exons,@tmpexons);
    };
    if ($@) {
      print ("Error testing genscans - skipping feature\n");
    }
   }
}


my $wvc    = new Bio::EnsEMBL::DB::WriteableVirtualContig(-focuscontig   => $contig,
                                                          -gene_obj      => $db->gene_Obj,
                                                          -focusposition => $focus,
                                                          -ori           => 1,
                                                          -left          => 1000000000,
                                                          -right         => 1000000000);


foreach my $exon (@exons) {
   print ("\nReverse mapping " . $exon->id . "\t" . $exon->seqname . "\t" . $exon->start . "\t" . $exon->end . "\n");

   my @newexons  = $wvc->_reverse_map_Exon($exon);

   foreach my $newexon (@newexons) {
      print ("New exon " . $newexon->id . "\t" . $newexon->start . "\t" . $newexon->end . "\n");
   }

}

sub test_genscan {
  my ($gs,$vc) = @_;

  $gs->attach_seq($vc->primary_seq);

  my $mrna = "";
  my $strand;
  my @exons;
  my $count = 1;

  foreach my $f ($gs->sub_SeqFeature) {
    $mrna .= $f->seq->seq;
    $strand = $f->strand;

    # make an exon for the writeback test
    my $exon = new Bio::EnsEMBL::Exon;
    $exon->id($gs->id . ".$count");
    $exon->seqname($gs->seqname);
    $exon->start ($f->start);
    $exon->end   ($f->end);
    $exon->strand($f->strand);
    push(@exons,$exon);
  }

  my $dnaseq = new Bio::PrimarySeq(-id  => "mrna",
                                   -seq => $mrna);

  my $phase;

  if ($dnaseq->translate('*','X',0)->seq !~ /\*/) {
     $phase = 0;
   } elsif ($dnaseq->translate('*','X',2)->seq !~ /\*/) {
     $phase = 1;
   } elsif ($dnaseq->translate('*','X',1)->seq !~ /\*/) {
     $phase = 2;
   } else {
     warn("No translateable frame for genscan prediction ".$strand.":".$gs->seqname);
     return;
   }
   print ("Translation is " . $gs->id . " " . $dnaseq->translate('*','X',(3-$phase)%3)->seq . "\n");

   foreach my $exon (@exons) {
	$exon->phase($phase);
        $phase = $exon->end_phase;
   }
   return @exons;
}


sub make_locator_string {
    my ($type,$module,$host,$port,$dbname,$dbuser,$dbpass,$perl) = @_;

    return "$module/host=$host;port=$port;dbname=$dbname;user=$dbuser;pass=$dbpass;perlonlyfeatures=$perl";

}

