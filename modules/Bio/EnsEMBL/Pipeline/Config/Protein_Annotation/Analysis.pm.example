The variables can also be references to arrays or hashes.

Edit C<%Analysis> to add or alter variables.

All the variables are in capitals, so that they resemble environment
variables.

=head1 CONTACT

=cut


package Bio::EnsEMBL::Pipeline::Config::Protein_Annotation::Analysis;

use strict;
use vars qw( %Analysis );

# Hash containing config info
%Analysis = (
	     Analysis_type[
			   {
			    logic_name => '', # logic name in analysis table
			    module => '', #module path, the runner script adds this to the start Bio/EnsEMBL/Pipeline/RunnableDB so if module in RunnableDB/Protein will need to have Protein/ on name
			    program_file => '', # location of binary
			    db_file => '', #location of any db file needed
			    db => '', # more human name for db
			    chunk_size => '', # this can be three things, single which means it will run on a single transcript, chunk which means 
			                       # it will run on a chunk file and genome which means it will run on all the transcripts in the genome
			    gff_source => '', # program name
			    gff_feature => '', # domain or annotation
			    parameters => '',
			   }
			  ]
	   );

sub import {
  my ($callpack) = caller(0); # Name of the calling package
  my $pack = shift; # Need to move package off @_
  
  # Get list of variables supplied, or else
  # all of Analysis:
  my @vars = @_ ? @_ : keys( %Analysis );
  return unless @vars;
  
  # Predeclare global variables in calling package
  eval "package $callpack; use vars qw("
    . join(' ', map { '$'.$_ } @vars) . ")";
    die $@ if $@;


    foreach (@vars) {
	if ( defined $Analysis{ $_ } ) {
            no strict 'refs';
	    # Exporter does a similar job to the following
	    # statement, but for function names, not
	    # scalar variables:
	    *{"${callpack}::$_"} = \$Analysis{ $_ };
	} else {
	    die "Error: Analysis: $_ not known\n";
	}
    }
}

1;
